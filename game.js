
const symbols = ['lightstick','mic','disco','sneaker','album','headphone','star','heart'];
const specials = ['fog','curse','lock'];
const state = { deck: [], flipped: [], matched: new Set(), locked:false, time: 60, timer: null, score:0, streak:0, boost:1.0, pairs:0, audioOn:false, effects:{frozen:0} };
const $ = id => document.getElementById(id);
const grid = $('grid'), toast=$('toast'); const audio = $('bgm');
const sfxMatch=$('sfxMatch'), sfxMiss=$('sfxMiss'), sfxPower=$('sfxPower'); const confetti = $('confetti'), stick = $('stick'); const fog = $('fog');
function shuffle(a){ for(let i=a.length-1;i>0;i--){ const j=Math.floor(Math.random()*(i+1)); [a[i],a[j]]=[a[j],a[i]] } return a; }
function showToast(msg){ toast.textContent=msg; toast.classList.add('show'); setTimeout(()=>toast.classList.remove('show'),1200); }
function buildDeck(){ const base = symbols.flatMap(s=>[{sym:s,type:'sym'},{sym:s,type:'sym'}]); const spec = specials.flatMap(s=>[{sym:s,type:'spec'},{sym:s,type:'spec'}]); const deck = shuffle([...base, ...spec]).slice(0,24); return deck.map((c,i)=>({...c,id:i,flipped:false})); }
function cardFace(c){ if(c.type==='spec'){ const label = c.sym==='fog'?'🌫️ Fog': c.sym==='curse'?'🕸️ Curse':'🔒 Lock'; return `<div class="face front"><span class="badge">${label}</span></div>`;} return `<div class="face front"><img src="assets/${c.sym}.svg" alt="${c.sym}"></div>`;}
function cardBack(){ return `<div class="face back"><img src="assets/back.svg" alt="card back"></div>`; }
function render(){ grid.innerHTML=''; state.deck.forEach((c)=>{ const el=document.createElement('div'); el.className='card'+(c.flipped?' flip':''); el.dataset.id=String(c.id); el.tabIndex=0; el.setAttribute('role','button'); el.innerHTML = cardBack()+cardFace(c); grid.appendChild(el); }); $('time').textContent=String(state.time); $('streak').textContent=String(state.streak); $('boost').textContent='x'+state.boost.toFixed(1); $('score').textContent=String(state.score); $('pairs').textContent=`${state.pairs}/8`; }
function startTimer(){ clearInterval(state.timer); state.timer=setInterval(()=>{ if(state.effects.frozen>0){ state.effects.frozen--; return; } state.time--; $('time').textContent=String(state.time); if(state.time<=0){ clearInterval(state.timer); endGame(false); } },1000); }
function endGame(win){ state.locked=true; if(win){ const img = confetti.cloneNode(); img.style.position='fixed'; img.style.inset='0'; img.style.objectFit='cover'; img.style.pointerEvents='none'; img.style.zIndex=50; document.body.appendChild(img); setTimeout(()=>img.remove(), 1800); } showToast(win?`🏆 Winner! Score ${state.score}`:`⏳ Time's up! Score ${state.score}`); }
function reset(){ Object.assign(state,{ deck:buildDeck(), flipped:[], matched:new Set(), locked:false, time:60, score:0, streak:0, boost:1.0, pairs:0, effects:{frozen:0} }); render(); startTimer(); showToast('New game!'); }
function addScore(base){ const s = Math.round(base*state.boost); state.score += s; $('score').textContent=String(state.score); }
function onMatch(a,b){ state.matched.add(a); state.matched.add(b); state.pairs++; $('pairs').textContent=`${state.pairs}/8`; state.streak++; if(state.streak%2===0) state.boost=Math.min(2.0, state.boost+0.2); $('streak').textContent=String(state.streak); $('boost').textContent='x'+state.boost.toFixed(1); addScore(100); sfxMatch.currentTime=0; sfxMatch.play(); const img = stick.cloneNode(); img.style.position='fixed'; img.style.left='16px'; img.style.bottom='16px'; img.style.width='110px'; img.style.pointerEvents='none'; img.style.zIndex=45; document.body.appendChild(img); setTimeout(()=>img.remove(), 900); showToast('Matched! 🔥'); if(state.pairs>=8){ clearInterval(state.timer); endGame(true); } }
function onMismatch(a,b){ state.streak=0; state.boost=Math.max(1, state.boost-0.1); $('streak').textContent='0'; $('boost').textContent='x'+state.boost.toFixed(1); sfxMiss.currentTime=0; sfxMiss.play(); setTimeout(()=>{ [a,b].forEach(i=>{ if(!state.matched.has(i)) state.deck[i].flipped=false; }); state.locked=false; render(); },650); }
function applySpecial(i){ const c = state.deck[i]; if(c.sym==='fog'){ fog.classList.add('show'); sfxPower.currentTime=0; sfxPower.play(); setTimeout(()=>fog.classList.remove('show'), 1400); }else if(c.sym==='curse'){ showToast('🌀 Cursed shuffle!'); sfxPower.currentTime=0; sfxPower.play(); const locked=[], remain=[]; state.deck.forEach((x,idx)=> state.matched.has(idx)?locked.push({x,idx}):remain.push(x)); shuffle(remain); const nd=[]; let r=0; for(let k=0;k<state.deck.length;k++){ nd[k] = state.matched.has(k)?locked.shift().x:remain[r++]; } state.deck = nd.map((x,k)=>({...x,id:k,flipped:false})); }else if(c.sym==='lock'){ showToast('🔒 Locked!'); sfxPower.currentTime=0; sfxPower.play(); state.locked = true; setTimeout(()=>state.locked=false, 1500); } }
function flipCard(idx){ const c = state.deck[idx]; if(state.locked || c.flipped || state.matched.has(idx)) return; c.flipped=true; render(); if(c.type==='spec'){ applySpecial(idx); setTimeout(()=>{ c.flipped=false; render(); }, 520); return; } state.flipped.push(idx); if(state.flipped.length===2){ state.locked=true; const [a,b] = state.flipped; state.flipped=[]; if(state.deck[a].sym===state.deck[b].sym){ onMatch(a,b); state.locked=false; } else { onMismatch(a,b); } } }
grid.addEventListener('click', e=>{ const d=e.target.closest('.card'); if(!d) return; flipCard(Number(d.dataset.id)); });
grid.addEventListener('keydown', e=>{ if(e.key==='Enter'||e.key===' '){ const d=e.target.closest('.card'); if(!d) return; flipCard(Number(d.dataset.id)); }});
$('btn-reveal').addEventListener('click', ()=>{ if(state.time<=3) return showToast('Not enough time!'); const prev = state.deck.map(c=>c.flipped); state.deck.forEach(c=>c.flipped=true); render(); state.time-=3; $('time').textContent=String(state.time); sfxPower.currentTime=0; sfxPower.play(); setTimeout(()=>{ state.deck.forEach((c,i)=>c.flipped = prev[i] || state.matched.has(i)); render(); }, 850); });
$('btn-freeze').addEventListener('click', ()=>{ state.effects.frozen+=5; sfxPower.currentTime=0; sfxPower.play(); showToast('❄️ Time frozen!'); });
$('btn-shuffle').addEventListener('click', ()=>{ const locked=[], remain=[]; state.deck.forEach((x,idx)=> state.matched.has(idx)?locked.push({x,idx}):remain.push(x)); shuffle(remain); const nd=[]; let r=0; for(let k=0;k<state.deck.length;k++){ nd[k] = state.matched.has(k)?locked.shift().x:remain[r++]; } state.deck = nd.map((x,k)=>({...x,id:k,flipped:false})); sfxPower.currentTime=0; sfxPower.play(); render(); showToast('🔀 Shuffled!'); });
$('btn-new').addEventListener('click', reset);
$('btn-audio').addEventListener('click', (e)=>{ state.audioOn=!state.audioOn; e.target.textContent = 'Music: ' + (state.audioOn ? 'On' : 'Off'); if(state.audioOn){ audio.volume=0.35; audio.play().catch(()=>{}); } else { audio.pause(); } });
reset();
